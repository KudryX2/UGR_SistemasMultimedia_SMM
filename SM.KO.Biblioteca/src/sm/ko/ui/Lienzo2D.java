/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.ko.ui;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import sm.ko.graficos.Semicirculo;
import sm.ko.graficos.BoundingBox;
import sm.ko.graficos.Curva;
import sm.ko.graficos.Elipse;
import sm.ko.graficos.Libre;
import sm.ko.graficos.MiShape;
import sm.ko.graficos.TipoForma;
import sm.ko.graficos.Linea;
import sm.ko.graficos.Punto;
import sm.ko.graficos.Rectangulo;
/**
 *
 * @author Kudry
 */
public class Lienzo2D extends javax.swing.JPanel {

    private Graphics2D g2d;
    
    private TipoForma formaDibujado;
    private Color color;
    private BasicStroke grosor;
    private Composite transparencia;
    private RenderingHints alisado;
   
    private boolean editar,relleno;
    
    private MiShape formaActual;
    private BoundingBox boundingBox;
    private ArrayList<MiShape> vShape;
    
    
    /**
     * Creates new form Lienzo2D
     */
    public Lienzo2D() {
        initComponents();
          
        color = Color.black;
        
        grosor = new BasicStroke(1);
        alisado = null;
        transparencia = null;
        
        formaActual = null;
        boundingBox = new BoundingBox();
        vShape = new ArrayList();
        
        this.setBackground(Color.white);        
        this.setVisible(true);        
    }
    
    /**
     * Dibuja todos los elementos del lienzo y para ello recorre el vector
     * de formas que almacena y las dibuja una a una, tambien dibuja la forma
     * actual, es decir la que se esta dibujando en el momento en caso de que 
     * se haga y la bounding box en el caso de que haya una forma seleccionada
     * @param g renderer
     */
    @Override
    public void paint(Graphics g){
        super.paint(g);     
        g2d = (Graphics2D)g;   
        
        if(!vShape.isEmpty())
        for(MiShape s : vShape){
            s.draw(g2d);
        }
        
        if(formaActual != null && !editar){
            formaActual.draw(g2d);
        }
        
        if(editar && formaActual != null){
            boundingBox.draw(g2d);
        }     
        
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    /**
     * Procesamiento del evento de pulsacion del raton
     * En el caso de que se dibujen formas se crea una forma nueva, si es un 
     * punto se añade directamente al vector de formas y si no se almacena en 
     * la cariable auxiliar formaActual, la poscion donde se va a dibujar la 
     * forma se extrae del evento.
     * En caso de que se este editando, se comprueba si se ha seleccionado una 
     * forma y en el caso afirmativo se almacena en la variable auxiliar,
     * en este momento se graba la pisicion relativa de la figura seleccionada y
     * el raton.
     * @param evt evento de raton
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
  
        if(editar){
            
            formaActual = getSelectedShape(evt.getPoint());
            
            if(formaActual != null){
                formaActual.setOffset(evt.getPoint());
                boundingBox.setPosition(formaActual);
            }
            
        }else{
           
            if(formaDibujado == TipoForma.LIBRE){
                formaActual = new Libre(color,grosor,transparencia,alisado);
            }else if(formaDibujado == TipoForma.PUNTO){
                vShape.add(new Punto(evt.getPoint(),color,grosor,transparencia,alisado));
            }else if(formaDibujado == TipoForma.LINEA){
                formaActual = new Linea(evt.getPoint(),color,grosor,transparencia,alisado);
            }else if(formaDibujado == TipoForma.CURVA && formaActual == null){
                formaActual = new Curva(evt.getPoint(),color,grosor,transparencia,alisado);
            }else if(formaDibujado == TipoForma.RECTANGULO){
                formaActual = new Rectangulo(evt.getPoint(),color,grosor,transparencia,alisado,relleno);
            }else if(formaDibujado == TipoForma.ELIPSE){
                formaActual = new Elipse(evt.getPoint(),color,grosor,transparencia,alisado,relleno);
            }else if(formaDibujado == TipoForma.SEMICIRCULO){
                formaActual = new Semicirculo(evt.getPoint(),color,grosor,transparencia,alisado,relleno);
            }
            
        }
 
    }//GEN-LAST:event_formMousePressed

    /**
     * Procesamiento del evento de soltar el boton del raton
     * Si estamos dibujando, la forma auxiliar(formaActual) se añade al vector 
     * de formas y la forma actual se anula, en el caso de ser una digura 
     * cuyo dibujado necesite varios pasos como la figura "Curva" se actualizan
     * los pasos. En el caso de que se llegue al ultimo paso la figura se añade
     * al vector de formas.
     * En el caso de estar editando, la figura seleccionada se anula en el caso 
     * de que la posicion en la que se ha soltado el raton no coincide con la de
     * ninguna figura.
     * @param evt evento 
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased

        if(editar){
           
            if(getSelectedShape(evt.getPoint()) == null){
                formaActual = null;
            }
                
        }else{
            
            if(formaActual != null){                
                if(formaActual.getTipoForma() == TipoForma.CURVA && formaActual.getStep() == 0 ){
                    formaActual.increaseStep();
                }else{
                    formaActual.fixPosition();
                    vShape.add(formaActual);
                    formaActual = null;
                }
                
            }
            
        } 
        
        
        this.formMouseDragged(evt);
    }//GEN-LAST:event_formMouseReleased

    /**
     * Procesamiento de arrastrar el boton del raton 
     * En el caso de estar dibujando se actualiza el tamaño de la figura y en el
     * caso de que se este editando , se modifica la posicion de la figura 
     * seleccionada y la de su bounding box junto a eta.
     * @param evt evento
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        
        if(editar){
            
            if(formaActual != null){
                formaActual.moveTo(evt.getPoint());
                boundingBox.setPosition(formaActual);
            }
            
        }else{
            
            if(formaActual != null){
                formaActual.setSize(evt.getPoint());
            }
            
        }        
        
        this.repaint();
    }//GEN-LAST:event_formMouseDragged

    /**
     * Evento necesario para formas cuyo dibujado requiere dos pasos
     * Actualiza el tamaño de la figura
     * @param evt 
     */
    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        if(!editar && formaActual != null && formaActual.getTipoForma() == TipoForma.CURVA){
            formaActual.setSize(evt.getPoint());
            this.repaint();            
        }

    }//GEN-LAST:event_formMouseMoved
  
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    /**
     * Devuelve la figura que se encuentre en la posicion proporcionada, si no 
     * hay ninguna figura en esa posicion se devuelve null.
     * @param p posicion a comprobar
     * @return 
     */
    private MiShape getSelectedShape(Point2D p){
        for(MiShape s : vShape){
            if(s.contains(p)) return s;
        }
        return null;
    }   
    
    
    /**
     * Envia la figura seleccionada al fondo
     */
    public void enviarAlFondo(){
        vShape.remove(formaActual);
        vShape.add(0, formaActual);
        
        repaint();
    }
    
    /**
     *  Trae al frente la figura seleccionada
     */
    public void traerAlFrente(){
        vShape.remove(formaActual);
        vShape.add(formaActual);
        
        repaint();
    }
    
    /**
     * Envia atras la figura seleccionada
     */
    public void enviarAtras(){
        enviarAPosicion(vShape.indexOf(formaActual)-1);
        repaint();
    }
    
    /**
     * Tra al frente la figura seleccionada
     */
    public void traerAdelante(){
        enviarAPosicion(vShape.indexOf(formaActual)+1);
        repaint();
    }
    
    
    /**
     * Se intercambia la posicion de la digura seleccionada con la figura que
     * se encuentre en la posicion dada
     * @param index1 posicion de la figura a intercambiar
     */
    private void enviarAPosicion(int index1){
        if(index1 >= 0 || index1 < vShape.size()){
            MiShape aux = vShape.get(index1);
            int index2 = vShape.indexOf(formaActual);
            vShape.set(index1, formaActual);
            vShape.set(index2, aux);
        }
    }
    
    /*
        Setters/Update
    */
    
    /**
     * Actualiza la forma seleccionada 
     * @param formaSeleccionada forma de dibujado seleccionada
     */
    public void setFormaDibujado(TipoForma formaSeleccionada){
        this.formaDibujado = formaSeleccionada;
        editar = false;
        formaActual = null;
        repaint();
    }
    
    /**
     * Actualiza la opcion edidar del lienzo
     */
    public void updateEditar(){
        editar = !editar;
        
        if(!editar)
            formaActual = null;
        
        repaint();
    }
    
    // Atributos
    /**
     * Actualiza el color dibujado o modifica el de la figura seleccionada
     * @param color color nuevo
     */
    public void setColor(Color color){
        this.color = color;        
        
        if(editar && formaActual != null){
            formaActual.setColor(color);
            this.repaint();
        }   
    }
    
    /**
     * Actualiza el grosor de dibujado o modifica el de la figura seleccionada
     * @param grosor 
     */
    public void updateGrosor(int grosor){
        
        if(editar && formaActual != null){
            this.grosor = new BasicStroke(grosor);
            formaActual.setGrosor(this.grosor);
            repaint();
        }
    }
     
    /**
     * Actualiza el relleno de dibujado o el de la figura seleccionada
     */
    public void updateRelleno(){
        
        if(editar && formaActual != null){
            relleno = !relleno;
            formaActual.setRelleno(relleno);
            repaint();    
        }
        
    }
    
    /**
     * Actualiza la transparencia de dibujado o el de la figura seleccionada.
     */
    public void updateTransparencia(){
        if(transparencia == null){
            transparencia = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f);
        }else{
            transparencia = null;
        }
        
        if(editar && formaActual != null){
            formaActual.setTransparencia(transparencia);
            repaint();
        }
        
    }
    
    /**
     * Actualiza el alisado del dibujado o de la figura seleccionada
     */
    public void updateAlisado(){ 
        if(alisado == null){
            alisado = new RenderingHints(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
        }else{ 
            alisado = null;
        }
        
        if(editar && formaActual != null){
            formaActual.setAlisado(alisado);
            repaint();
        }
        
    }
    
    /*
        Getters
    */
    /**
     * Devuelve el vector de formas del lienzo
     * @return vector de formas
     */
    public ArrayList<MiShape> getVShape(){
        return vShape;
    }
    
    /**
     * Devuelve la figura seleccionada
     * @return figura actual
     */
    public MiShape getFormaActual(){
        return formaActual;
    }
    
    /**
     * Devuelve el color seleccionada
     * @return color
     */
    public Color getColor(){
        return color;
    }
    
    /**
     * Devuelve la forma de dibujado seleccionada
     * @return forma de dibujado
     */
    public TipoForma getFormaDibujado(){
        return formaDibujado;
    }
    
    /**
     * Devuelve el valor booleano de relleno 
     * @return relleno
     */
    public boolean getRelleno(){
        return relleno;
    }
    
    /**
     * Devuelve si se esta editando el lienzo o no 
     * @return editar
     */
    public boolean getEditar(){
        return editar;
    }
    
    /**
     * Devuelve la transparencia establecida en el lienzo
     * @return transparencia
     */
    public boolean getTransparencia(){
        if(transparencia == null)
            return false;
        else 
            return true;
    }
    
    /**
     * Devuelve el alisado seleccionado en el lienzo
     * @return alisado
     */
    public boolean getAlisado(){
        if(alisado == null){
            return false;
        }else{
            return true;
        }
    }
    
    /**
     * Devuelve el grosor seleccionado en el lienzo
     * @return 
     */
    public int getGrosor(){
        return (int) grosor.getLineWidth();
    }
}
